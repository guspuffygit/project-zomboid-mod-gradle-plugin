plugins {
    id 'java-gradle-plugin'
    id "com.gradle.plugin-publish" version "0.14.0"
    id 'maven-publish'
//	id("com.diffplug.gradle.spotless") version "8.1.0"
}

// exclude decompiler code from formatting
//spotless.java {
//	it.targetExclude '**/org/jetbrains/**/*'
//}
apply from: 'test.gradle'

version '0.4.2'
group 'io.pzstorm.capsid'

repositories {
    mavenCentral()
}

dependencies {
    implementation 'com.google.guava:guava:30.1-jre'

    compileOnly 'org.jetbrains:annotations:20.1.0'

    testImplementation group: 'org.junit.jupiter', name: 'junit-jupiter-api', version: '5.7.1'
    testImplementation group: 'org.junit.jupiter', name: 'junit-jupiter-engine', version: '5.7.1'
}

gradlePlugin {
    //noinspection GroovyAssignabilityCheck
    plugins {
        capsid {
            id = 'io.pzstorm.capsid'
            implementationClass = 'io.pzstorm.capsid.CapsidPlugin'
        }
    }
    testSourceSets(sourceSets.integrationTest, sourceSets.functionalTest)
}

pluginBundle {
    website = 'https://github.com/pzstorm/capsid'
    vcsUrl = 'https://github.com/pzstorm/capsid'
    description = 'Project Zomboid mod development framework for Gradle'
    tags = ['java', 'project-zomboid', 'modding', 'framework']

    plugins {
        capsid.displayName = 'Storm Capsid'
    }
}

// publish to mavenLocal every time we build project
getTasks().named('classes').configure({
    it.finalizedBy('publishToMavenLocal')
})
// publish to mavenLocal after all classes have been compiled
publishToMavenLocal {
    mustRunAfter('testClasses', 'functionalTestClasses', 'integrationTestClasses')
}

// turn off doclint for Javadoc tasks
// https://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html
tasks.withType(Javadoc) {
    options.addStringOption('Xdoclint:none', '-quiet')
}
// include license files in artifact jar
jar.from 'LICENSE', 'NOTICE'

sourceSets {
    functionalTest {
        compileClasspath += sourceSets.main.output
        runtimeClasspath += sourceSets.main.output
    }
    integrationTest {
        compileClasspath += sourceSets.main.output
        runtimeClasspath += sourceSets.main.output
    }
}

configurations {
    functionalTestImplementation.extendsFrom(implementation, testImplementation)
    integrationTestImplementation.extendsFrom(implementation, testImplementation)
}

test {
    useJUnitPlatform()
    testLogging.events "passed", "skipped", "failed"
}

def integrationTest = tasks.register('integrationTest', Test) {
    it.useJUnitPlatform()
    it.testLogging.events "passed", "skipped", "failed"
    it.testClassesDirs = sourceSets.integrationTest.output.classesDirs
    it.classpath = sourceSets.integrationTest.runtimeClasspath
    it.shouldRunAfter("test")
}

tasks.register('functionalTest', Test) {
    it.useJUnitPlatform()
    it.environment 'jupiter.functionalTest', 'true'
    it.testLogging.events "passed", "skipped", "failed"
    it.testClassesDirs = sourceSets.functionalTest.output.classesDirs
    it.classpath = sourceSets.functionalTest.runtimeClasspath
    it.shouldRunAfter(integrationTest, "test")
}

task runTests {
    description 'Run all test categories in order.'
    group 'verification'

    tasks.withType(Test.class).each {
        dependsOn(it)
    }
}
tasks.named('check') {
    it.dependsOn(tasks.functionalTest, tasks.integrationTest)
}
